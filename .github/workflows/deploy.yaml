name: build-and-deploy
on:
  push:
    branches: ["main"]
    paths:
      - "web-revised/**"
      - "was/**"
      - "apps/web-frontend/**"
      - "apps/was-api/**"

permissions:
  contents: write
  packages: write

concurrency:
  group: build-deploy
  cancel-in-progress: true

env:
  IMAGE_WEB: ghcr.io/unklo1200/web-updated
  IMAGE_WAS: ghcr.io/unklo1200/was-updated
  TAG: v${{ github.run_number }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Login to GHCR
        run: echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u unklo1200 --password-stdin

      - name: Detect changes (web & was)
        id: ch
        run: |
          set -euo pipefail
          WEB_CHANGED=false
          WAS_CHANGED=false
          if git rev-parse --verify HEAD^ >/dev/null 2>&1; then
            git diff --quiet HEAD^ HEAD -- web-revised apps/web-frontend || WEB_CHANGED=true
            git diff --quiet HEAD^ HEAD -- was         apps/was-api      || WAS_CHANGED=true
          else
            WEB_CHANGED=true
            WAS_CHANGED=true
          fi
          echo "web=${WEB_CHANGED}" >> "$GITHUB_OUTPUT"
          echo "was=${WAS_CHANGED}" >> "$GITHUB_OUTPUT"

      - name: Build & Push Web
        if: steps.ch.outputs.web == 'true'
        run: |
          set -euo pipefail
          docker build -t ${IMAGE_WEB}:${TAG} -f web-revised/Dockerfile web-revised
          docker push  ${IMAGE_WEB}:${TAG}
          echo "DIGEST_WEB=$(docker inspect --format='{{index .RepoDigests 0}}' ${IMAGE_WEB}:${TAG})" >> "$GITHUB_ENV"

      - name: Build & Push WAS
        if: steps.ch.outputs.was == 'true'
        run: |
          set -euo pipefail
          docker build -t ${IMAGE_WAS}:${TAG} -f was/Dockerfile was
          docker push  ${IMAGE_WAS}:${TAG}
          echo "DIGEST_WAS=$(docker inspect --format='{{index .RepoDigests 0}}' ${IMAGE_WAS}:${TAG})" >> "$GITHUB_ENV"

      - name: Update manifests (web)
        if: steps.ch.outputs.web == 'true'
        run: |
          set -euo pipefail
          sed -i "s#image: .*web-updated.*#image: ${DIGEST_WEB}#g" apps/web-frontend/webapp.yaml
          git config user.name "ci-bot"
          git config user.email "ci-bot@users.noreply.github.com"
          git commit -am "web: deploy ${TAG} (${DIGEST_WEB})" || echo "no manifest change"

      - name: Update manifests (was)
        if: steps.ch.outputs.was == 'true'
        run: |
          set -euo pipefail
          sed -i "s#image: .*was-updated.*#image: ${DIGEST_WAS}#g" apps/was-api/wasapp.yaml
          git config user.name "ci-bot"
          git config user.email "ci-bot@users.noreply.github.com"
          git commit -am "was: deploy ${TAG} (${DIGEST_WAS})" || echo "no manifest change"

      - name: Push changes
        if: steps.ch.outputs.web == 'true' || steps.ch.outputs.was == 'true'
        run: git push

      # ===== 공통: kubeconfig + 포트포워딩 동기화 =====
      - name: Load kubeconfig
        env:
          KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_DATA }}
        run: |
          set -euo pipefail
          mkdir -p "$HOME/.kube"
          if printf '%s\n' "$KUBE_CONFIG_DATA" | head -n1 | grep -q '^apiVersion: v1'; then
            printf '%s' "$KUBE_CONFIG_DATA" > "$HOME/.kube/config"
          else
            printf '%s' "$KUBE_CONFIG_DATA" | base64 -d > "$HOME/.kube/config"
          fi
          chmod 600 "$HOME/.kube/config"

      - name: Install tools
        run: |
          set -euo pipefail
          if ! command -v kubectl >/dev/null 2>&1; then
            curl -sLO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
            chmod +x kubectl && sudo mv kubectl /usr/local/bin/
          fi
          if ! command -v argocd >/dev/null 2>&1; then
            curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
            chmod +x /usr/local/bin/argocd
          fi

      - name: ArgoCD Sync Web
        if: steps.ch.outputs.web == 'true'
        env:
          ARGOCD_AUTH_TOKEN: ${{ secrets.ARGOCD_AUTH_TOKEN }}
        run: |
          set -euo pipefail
          kubectl -n argocd port-forward svc/argocd-server 8443:443 >/tmp/argocd-pf-web.log 2>&1 &
          PF_PID=$!
          for i in {1..20}; do
            curl -sk https://localhost:8443/ >/dev/null 2>&1 && break
            sleep 0.5
          done
          echo "::add-mask::${ARGOCD_AUTH_TOKEN}"
          argocd login "localhost:8443" --auth-token "$ARGOCD_AUTH_TOKEN" --insecure
          argocd app sync web-frontend --grpc-web --prune
          argocd app wait web-frontend --health --timeout 300
          kill $PF_PID || true

      - name: ArgoCD Sync WAS
        if: steps.ch.outputs.was == 'true'
        env:
          ARGOCD_AUTH_TOKEN: ${{ secrets.ARGOCD_AUTH_TOKEN }}
        run: |
          set -euo pipefail
          kubectl -n argocd port-forward svc/argocd-server 8444:443 >/tmp/argocd-pf-was.log 2>&1 &
          PF_PID=$!
          for i in {1..20}; do
            curl -sk https://localhost:8444/ >/dev/null 2>&1 && break
            sleep 0.5
          done
          echo "::add-mask::${ARGOCD_AUTH_TOKEN}"
          argocd login "localhost:8444" --auth-token "$ARGOCD_AUTH_TOKEN" --insecure
          argocd app sync was-api --grpc-web --prune
          argocd app wait was-api --health --timeout 300
          kill $PF_PID || true
